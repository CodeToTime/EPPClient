/*
 * SPDX-FileCopyrightText: 2008-2025 AssoTLD <reg@assotld.it>
 * SPDX-FileCopyrightText: 2026 Riccardo Bertelli
 *
 * SPDX-License-Identifier: GPL-3.0-or-later
 *
 * This file is part of EPPClient.
 *
 * EPPClient is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 *
 * EPPClient is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with EPPClient. If not, see <https://www.gnu.org/licenses/>.
 */

package EPPClient.domains;

import EPPClient.db.domainsDao;
import EPPClient.domains.transfer.TransferManagement;
import EPPClient.importer.ImportDomain;
import EPPClient.logger;
import EPPClient.main;
import EPPClient.uplink.EPPuplink;
import it.nic.epp.client.commands.converters.AbstractHostsConverter.Host;
import it.nic.epp.client.commands.query.DomainCheck;
import it.nic.epp.client.commands.query.DomainInfo;
import it.nic.epp.client.commands.transform.DomainCreate;
import it.nic.epp.client.commands.transform.DomainDelete;
import it.nic.epp.client.commands.transform.DomainUpdate;
import it.nic.epp.client.commands.transform.DomainUpdate.DomainUpdateStatusType;
import it.nic.epp.client.exceptions.EppSchemaException;
import it.nic.epp.client.responses.HttpBaseResponse;
import it.nic.epp.client.responses.resData.DomainCheckResponseResData;
import it.nic.epp.client.responses.resData.DomainCreateResponseResData;
import it.nic.epp.client.responses.resData.DomainInfoResponseResData;
import org.apache.xmlbeans.XmlException;

import javax.swing.*;
import javax.swing.border.LineBorder;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.io.IOException;
import java.util.List;
import java.util.Vector;

public class DomainsManagement extends JFrame implements ActionListener, ListSelectionListener
{

  private main mainFrame;

  /**
   * Creates new form ContactsManagement
   */
  public DomainsManagement(main mainFrame)
  {
    initComponents();

    windowAdapter = new WindowCloser();
    this.addWindowListener(windowAdapter);
    addressActionPanel.addActionListener(this);
    domainPanel.setEditable(false);
    addressListPanel.addListSelectionListener(this);

    this.mainFrame = mainFrame;
    this.EPPuplink = mainFrame.EPPuplink;
    this.db = mainFrame.domainsDao;


    refreshDomainList();


    logger = new logger("DOMAIN");

  }

  /**
   * This method is called from within the constructor to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the Form Editor.
   */
  @SuppressWarnings("unchecked")
  // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents

  private void initComponents() {
      addressActionPanel = new DomainActionPanel();
      domainPanel = new DomainPanel();
      addressListPanel = new DomainListPanel();

      //======== this ========
      setTitle("Gestione DOMINI");
      Container contentPane = getContentPane();

      //---- addressActionPanel ----
      addressActionPanel.setMinimumSize(new Dimension(50, 23));

      //---- domainPanel ----
      domainPanel.setBorder(LineBorder.createBlackLineBorder());

      GroupLayout contentPaneLayout = new GroupLayout(contentPane);
      contentPane.setLayout(contentPaneLayout);
      contentPaneLayout.setHorizontalGroup(
          contentPaneLayout.createParallelGroup()
              .addGroup(contentPaneLayout.createSequentialGroup()
                  .addContainerGap()
                  .addComponent(addressListPanel, GroupLayout.PREFERRED_SIZE, 247, GroupLayout.PREFERRED_SIZE)
                  .addGroup(contentPaneLayout.createParallelGroup()
                      .addGroup(contentPaneLayout.createSequentialGroup()
                          .addGap(57, 57, 57)
                          .addComponent(addressActionPanel, GroupLayout.DEFAULT_SIZE, GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                      .addGroup(GroupLayout.Alignment.TRAILING, contentPaneLayout.createSequentialGroup()
                          .addPreferredGap(LayoutStyle.ComponentPlacement.RELATED, GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                          .addComponent(domainPanel, GroupLayout.PREFERRED_SIZE, 1310, GroupLayout.PREFERRED_SIZE)))
                  .addContainerGap())
      );
      contentPaneLayout.setVerticalGroup(
          contentPaneLayout.createParallelGroup()
              .addGroup(contentPaneLayout.createSequentialGroup()
                  .addContainerGap()
                  .addGroup(contentPaneLayout.createParallelGroup()
                      .addGroup(contentPaneLayout.createSequentialGroup()
                          .addComponent(domainPanel, GroupLayout.PREFERRED_SIZE, GroupLayout.DEFAULT_SIZE, GroupLayout.PREFERRED_SIZE)
                          .addPreferredGap(LayoutStyle.ComponentPlacement.RELATED, 33, Short.MAX_VALUE)
                          .addComponent(addressActionPanel, GroupLayout.PREFERRED_SIZE, GroupLayout.DEFAULT_SIZE, GroupLayout.PREFERRED_SIZE))
                      .addComponent(addressListPanel, GroupLayout.DEFAULT_SIZE, 783, Short.MAX_VALUE))
                  .addContainerGap())
      );
      pack();
      setLocationRelativeTo(getOwner());
  }// </editor-fold>//GEN-END:initComponents

  public void setEPPEnablement(boolean EPPstatus)
  {
    addressActionPanel.setVisible(EPPstatus);
  }

  private void refreshDomainList()
  {
    addressListPanel.deleteAllEntries();
//        db = new domainsDao();
//        db.connect();
    List<ListEntry> entries = db.getListEntries();
//        db.disconnect();
    addressListPanel.addListEntries(entries);
  }

  private void cancelAddress()
  {
    domainPanel.clear();
    domainPanel.setEditable(false);
    ListEntry entry = addressListPanel.getSelectedListEntry();
    if (entry != null)
    {
      String contactId = entry.getDomainName();
//            db = new domainsDao();
//            db.connect();
      Domain address = db.getDomain(contactId);
//            db.disconnect();
      domainPanel.setAddress(address);
    }


  }

  private void newAddress()
  {
    domainPanel.clear();
    domainPanel.setOpType(1);
    domainPanel.setEditable(true);
  }

  private void transferAddress()
  {
//        addressPanel.clear();

    TransferManagement domainTransferFrame = new TransferManagement(EPPuplink);

    domainTransferFrame.setVisible(true);

  }

  private void deleteDomain()
  {
    String domainName = domainPanel.getDomainName();

    if (JOptionPane.showOptionDialog(this, "Do you REALLY want to delete the domain " + domainName + "?", "Confirm domain Delete", JOptionPane.YES_NO_OPTION, JOptionPane.QUESTION_MESSAGE, null, null, null) == JOptionPane.YES_OPTION)
    {

      if (!domainName.equals(""))
      {

        try
        {
          DomainDelete domainDelete = new DomainDelete(domainName);
          logger.logmessage("CLIENT: " + domainDelete.toString());
          HttpBaseResponse response = EPPuplink.sendCommand(domainDelete);
          logger.logmessage("SERVER: " + response.toString() + "\n");

          if (response.isSuccessfully())
          {
            Domain domain = domainPanel.getAddress();
            Vector newStatus = domain.getNewStatusV();
            newStatus.add(99);
            domain.setNewStatus(newStatus);
            //                db = new domainsDao();
            //                db.connect();
            db.editRecord(domain);
            //                db.disconnect();
          }
          else
          {
            if (JOptionPane.showConfirmDialog(this, "An error occurred while deleting the domain on Registry.\n\nDo you want to see the Registry XML response?", "Registry update failure", JOptionPane.YES_NO_OPTION, JOptionPane.WARNING_MESSAGE) == 0)
            {
              JOptionPane.showMessageDialog(this, response.toString());
            }
            parseDomainResult(response);
          }

    /*                // send the logout command with verbose interaction
                    Logout logout = new Logout();
                    logger.logmessage("CLIENT: "+ logout.toString() + "\n");
                    response = client.sendCommand(logout);
                    logger.logmessage("SERVER: "+ response.toString());
     */
        }
        catch (NullPointerException v)
        {
        }
        catch (XmlException v)
        {
        }
        catch (IOException v)
        {
        }

      }
      else
      {
        domainPanel.clear();
      }
    }
    domainPanel.setEditable(false);


  }

  private void editAddress()
  {
    int selected = addressListPanel.getSelectedIndex();
    if (selected >= 0)
    {
      domainPanel.setEditable(true);
    }

  }

  private void saveAddress()
  {
    if (domainPanel.isEditable())
    {
      Domain domain = domainPanel.getAddress();
      String domainName = domain.getDomainName();

      if (domain.getOpType() == 1)
      {
        try
        {
          DomainCreate domainCreate = new DomainCreate(domain.getDomainName());
          domainCreate.setRegistrant(domain.getRegistrant());

          String[] newAdmin = domain.getAdmin();
          for (int j = 0; j < newAdmin.length; j++)
          {
            domainCreate.addAdmin(newAdmin[j]);
          }

          String[] newTech = domain.getTech();
          for (int j = 0; j < newTech.length; j++)
          {
            domainCreate.addTech(newTech[j]);

          }


          String[] newNameServer = domain.getNameServer();
          for (int j = 0; j < newNameServer.length; j++)
          {
            if (newNameServer[j].contains("@"))
            {
              String[] dNameServer = newNameServer[j].split("@");
              try
              {
                domainCreate.addHostAttrName(dNameServer[0]);
                for (int i = 1; i < dNameServer.length; i++)
                {
                  domainCreate.addHostAttrAddr(j, dNameServer[i], ipAddressValidator.validateIpAddress(dNameServer[i]));
                }
              }
              catch (Exception e)
              {
                System.err.println("Invalid IP Address");
              }
            }
            else
            {
              domainCreate.addHostAttrName(newNameServer[j]);
            }
          }

          domainCreate.setAuthInfo(domain.getAuthInfo());
          if(!domain.getValidationCode().isEmpty()) {
            domainCreate.setExtValidationCode(domain.getValidationCode());
          }
          if(domain.isDNSSec()) {
            domainCreate.addDsData(Integer.parseInt(domain.getKeyTag()), (short) domain.getAlg(), (short) domain.getDigestType(),  parseHex(domain.getDigest()));
          }
          logger.logmessage("CLIENT: " + domainCreate.toString() + "\n");
          HttpBaseResponse response = EPPuplink.sendCommand(domainCreate);
          logger.logmessage("SERVER: " + response.toString() + "\n");

          if (response.isSuccessfully())
          {
            DomainCreateResponseResData domainCreateResData = (DomainCreateResponseResData) response.getResponseResData();
            domain.setExpire(domainCreateResData.getExDate().getTime());
            domainName = db.saveRecord(domain);
            domain.setOpType(0);

            ListEntry entry = new ListEntry(domainName);
            addressListPanel.addListEntry(entry);
            addressListPanel.setSelectedIndex(Integer.MAX_VALUE);

            domainPanel.setEditable(false);
          }
          else
          {
            if (JOptionPane.showConfirmDialog(this, "An error occurred while applying changes to the Registry.\n\nDo you want to see the Registry XML response?", "Registry update failure", JOptionPane.YES_NO_OPTION, JOptionPane.WARNING_MESSAGE) == 0)
            {
              JOptionPane.showMessageDialog(this, response.toString());
            }
          }

        }
        catch (NullPointerException v)
        {
          v.printStackTrace();
        }
        catch (XmlException v)
        {
          v.printStackTrace();
        }
        catch (IOException v)
        {
          v.printStackTrace();
        }


      }
      else
      {


        try
        {
          DomainInfo domainInfo = new DomainInfo();
          domainInfo.setName(domain.getDomainName());
          HttpBaseResponse response = EPPuplink.sendCommand(domainInfo);
          if (response.isSuccessfully())
          {
            logger.logmessage("DomainInfo PRIMA: " + response.toString() + "\n");
            DomainInfoResponseResData domainInfoResData = (DomainInfoResponseResData) response.getResponseResData();

            DomainUpdate domainUpdate = new DomainUpdate(domain.getDomainName());
            //domainUpdate.setAllToSecDNSRem();
            if(domain.isDNSSec()) {
              domainUpdate.addDsDataToSecDNSAdd(Integer.parseInt(domain.getKeyTag()), (short) domain.getAlg(), (short) domain.getDigestType(),  parseHex(domain.getDigest()));
            }
            //domainUpdate.addDsDataToSecDNSRem();

            String[] newAdmin = domain.getAdmin();

            for (int j = 0; j < newAdmin.length; j++)
            {
              boolean isAdminToAdd = true;

              if (domainInfoResData.getAdminsSize() > 0)
              {
                for (String oldAdmin : domainInfoResData.getAdmins())
                {
                  if (oldAdmin.equals(newAdmin[j]))
                  {
                    isAdminToAdd = false;
                  }
                }
              }

              if (isAdminToAdd)
              {
                domainUpdate.addAdminToAdd(newAdmin[j]);
              }
            }

            if (domainInfoResData.getAdminsSize() > 0)
            {
              for (String oldAdmin : domainInfoResData.getAdmins())
              {
                boolean isAdminToRem = true;

                if (newAdmin != null)
                {
                  for (int k = 0; k < newAdmin.length; k++)
                  {
                    if (newAdmin[k].equals(oldAdmin))
                    {
                      isAdminToRem = false;
                    }
                  }
                }

                if (isAdminToRem)
                {
                  domainUpdate.addAdminToRem(oldAdmin);
                }
              }
            }

            if (!domain.getOldAuthInfo().equals(domain.getAuthInfo()))
            {
              domainUpdate.setAuthInfo(domain.getAuthInfo());
            }

            if (!domainInfoResData.getRegistrant().equals(domain.getRegistrant()))
            {
              //if changing Registrant make a custom update request
              domainUpdate.setRegistrant(domain.getRegistrant());

              logger.logmessage("CLIENT: " + domainUpdate.toString() + "\n");
              response = EPPuplink.sendCommand(domainUpdate);
              logger.logmessage("SERVER: " + response.toString() + "\n");

              domainUpdate = new DomainUpdate(domain.getDomainName());
            }

            if (response.isSuccessfully())
            {
              for (String oldStatus : domainInfoResData.getStatuses())
              {
                int status = -1;
                if (oldStatus.equals("clientDeleteProhibited"))
                {
                  status = 0;
                }
                else if (oldStatus.equals("clientTransferProhibited"))
                {
                  status = 1;
                }
                else if (oldStatus.equals("clientUpdateProhibited"))
                {
                  status = 2;
                }
                boolean removeOldStatus = true;
                for (int i = 0; i < domain.getNewStatusV().size(); i++)
                {
                  if (domain.getNewStatusV().get(i) instanceof Integer)
                    if (status == (Integer) domain.getNewStatusV().get(i))
                      removeOldStatus = false;
                }
                if (removeOldStatus)
                  switch (status)
                  {
                    case 0:
                      domainUpdate.addStatusToRem(DomainUpdateStatusType.CLIENT_DELETE_PROHIBITED);
                      break;
                    case 1:
                      domainUpdate.addStatusToRem(DomainUpdateStatusType.CLIENT_TRANSFER_PROHIBITED);
                      break;
                    case 2:
                      domainUpdate.addStatusToRem(DomainUpdateStatusType.CLIENT_UPDATE_PROHIBITED);
                      break;
                  }

              }

              for (int i = 0; i < domain.getNewStatusV().size(); i++)
              {
                boolean addNewStatus = true;
                for (String oldStatus : domainInfoResData.getStatuses())
                {
                  int status = -1;
                  if (oldStatus.equals("clientDeleteProhibited"))
                  {
                    status = 0;
                  }
                  else if (oldStatus.equals("clientTransferProhibited"))
                  {
                    status = 1;
                  }
                  else if (oldStatus.equals("clientUpdateProhibited"))
                  {
                    status = 2;
                  }
                  if (status == (Integer) domain.getNewStatusV().get(i))
                    addNewStatus = false;
                }


                if (addNewStatus)
                  switch ((Integer) domain.getNewStatusV().get(i))
                  {
                    case 0:
                      domainUpdate.addStatusToAdd(DomainUpdateStatusType.CLIENT_DELETE_PROHIBITED);
                      break;
                    case 1:
                      domainUpdate.addStatusToAdd(DomainUpdateStatusType.CLIENT_TRANSFER_PROHIBITED);
                      break;
                    case 2:
                      domainUpdate.addStatusToAdd(DomainUpdateStatusType.CLIENT_UPDATE_PROHIBITED);
                      break;
                  }

              }


              String[] newTech = domain.getTech();

              for (int j = 0; j < newTech.length; j++)
              {
                boolean isTechToAdd = true;

                if (domainInfoResData.getTechsSize() > 0)
                {
                  for (String oldTech : domainInfoResData.getTechs())
                  {
                    if (oldTech.equals(newTech[j]))
                    {
                      isTechToAdd = false;
                    }
                  }
                }

                if (isTechToAdd)
                {
                  domainUpdate.addTechToAdd(newTech[j]);
                }
              }

              if (domainInfoResData.getTechsSize() > 0)
              {
                for (String oldTech : domainInfoResData.getTechs())
                {
                  boolean isTechToRem = true;

                  if (newTech != null)
                  {
                    for (int k = 0; k < newTech.length; k++)
                    {
                      if (newTech[k].equals(oldTech))
                      {
                        isTechToRem = false;
                      }
                    }
                  }

                  if (isTechToRem)
                  {
                    domainUpdate.addTechToRem(oldTech);
                  }
                }
              }


              String[] newNameServer = domain.getNameServer();
              String[] oldNameServer = domain.getOldNameServer();
              int countNameServerToAdd = 0;

              for (int j = 0; j < newNameServer.length; j++)
              {
                boolean isNameServerToAdd = true;

                if (domainInfoResData.getNsSize() > 0)
                {

                  for (Host oldHost : domainInfoResData.getNs())
                  {
                    if (newNameServer[j].contains("@"))
                    {

                      String[] dNameServer = newNameServer[j].split("@");

                      if (dNameServer[0].equals(oldHost.name))
                      {

                                            /*if (dNameServer[0].equals(oldHost.name)) {
                                                if (oldHost.getIpSize()>0)
                                                    if (dNameServer[1].equals(oldHost.getIp(0).address))
                                                        isNameServerToAdd = false;
                                            }*/


                        Boolean hostMatch = true;
                        for (int i = 1; i < dNameServer.length; i++)
                        {
                          Boolean ipFound = false;

                          for (int k = 0; k < oldHost.getIpSize(); k++)
                          {
                            if (dNameServer[i].equals(oldHost.getIp(k).address))
                              ipFound = true;
                          }

                          if (!ipFound)
                            hostMatch = false;
                        }

                        for (int i = 0; i < oldHost.getIpSize(); i++)
                        {
                          Boolean ipFound = false;
                          for (int k = 1; k < dNameServer.length; k++)
                          {
                            if (oldHost.getIp(i).address.equals(dNameServer[k]))
                              ipFound = true;
                          }

                          if (!ipFound)
                            hostMatch = false;
                        }
                        if (hostMatch)
                        {
                          isNameServerToAdd = false;
                        }
                      }


                    }
                    else
                    {
                      if (newNameServer[j].equals(oldHost.name))
                        isNameServerToAdd = false;
                    }
                  }
                }

                if (isNameServerToAdd)
                {
                  countNameServerToAdd += 1;

                  if (newNameServer[j].contains("@"))
                  {
                    String[] dNameServer = newNameServer[j].split("@");
                    try
                    {

                      domainUpdate.addHostAttrNameToAdd(dNameServer[0]);
                      for (int i = 1; i < dNameServer.length; i++)
                      {
                        domainUpdate.addHostAttrAddrToAdd(countNameServerToAdd - 1, dNameServer[i], ipAddressValidator.validateIpAddress(dNameServer[i]));
                      }

                    }
                    catch (Exception e)
                    {
                      System.err.println("Invalid IP Address");
                    }
                  }
                  else
                  {
                    domainUpdate.addHostAttrNameToAdd(newNameServer[j]);
                  }

                }
              }


              if (domainInfoResData.getNsSize() > 0)
              {
                for (Host oldHost : domainInfoResData.getNs())
                {
                  boolean isNameServerToRem = true;

                  if (newNameServer != null)
                  {
                    for (int k = 0; k < newNameServer.length; k++)
                    {
                      if (newNameServer[k].contains("@"))
                      {
                        String[] dNameServer = newNameServer[k].split("@");
                        if (dNameServer[0].equals(oldHost.name))
                        {
                          Boolean hostMatch = true;
                          for (int i = 1; i < dNameServer.length; i++)
                          {
                            Boolean ipFound = false;

                            for (int j = 0; j < oldHost.getIpSize(); j++)
                            {
                              if (dNameServer[i].equals(oldHost.getIp(j).address))
                                ipFound = true;
                            }

                            if (!ipFound)
                              hostMatch = false;
                          }

                          for (int i = 0; i < oldHost.getIpSize(); i++)
                          {
                            Boolean ipFound = false;
                            for (int j = 1; j < dNameServer.length; j++)
                            {
                              if (oldHost.getIp(i).address.equals(dNameServer[j]))
                                ipFound = true;
                            }

                            if (!ipFound)
                              hostMatch = false;
                          }
                          if (hostMatch)
                          {
                            isNameServerToRem = false;
                          }


                        }
                      }
                      else
                      {
                        if (newNameServer[k].equals(oldHost.getName()))
                          isNameServerToRem = false;
                      }
                    }
                  }

                  if (isNameServerToRem)
                  {
                    domainUpdate.addHostAttrNameToRem(oldHost.getName());
                  }
                }
              }

              logger.logmessage("CLIENT: " + domainUpdate.toString() + "\n");
              response = EPPuplink.sendCommand(domainUpdate);
              logger.logmessage("SERVER: " + response.toString() + "\n");

              if (response.isSuccessfully() || (response.getResultCode() == 2003 && response.getReasonCode() == 9019))
              {

                response = EPPuplink.sendCommand(domainInfo);
                logger.logmessage("DomainInfo DOPO: " + response.toString() + "\n");

                domainInfoResData = (DomainInfoResponseResData) response.getResponseResData();
                domain.setExpire(domainInfoResData.getExDate().getTime());

                db.editRecord(domain);
              }
              else
              {
                if (JOptionPane.showConfirmDialog(this, "An error occurred while applying changes to the Registry.\n\nDo you want to see the Registry XML response?", "Registry update failure", JOptionPane.YES_NO_OPTION, JOptionPane.WARNING_MESSAGE) == 0)
                {
                  JOptionPane.showMessageDialog(this, response.toString());
                }
                Domain address = db.getDomain(domain.getDomainName());
                domainPanel.setAddress(address);
              }
            }
            else
            {
              if (JOptionPane.showConfirmDialog(this, "An error occurred while applying changes to the Registry.\n\nDo you want to see the Registry XML response?", "Registry update failure", JOptionPane.YES_NO_OPTION, JOptionPane.WARNING_MESSAGE) == 0)
              {
                JOptionPane.showMessageDialog(this, response.toString());
              }
//                            db = new domainsDao();
//                            db.connect();
              Domain address = db.getDomain(domain.getDomainName());
//                            db.disconnect();
              domainPanel.setAddress(address);
            }

          }
          else
          {
            if (JOptionPane.showConfirmDialog(this, "An error occurred while making an InfoDomain to build change-list.\n\nDo you want to see the Registry XML response?", "Registry Domain Info failure", JOptionPane.YES_NO_OPTION, JOptionPane.WARNING_MESSAGE) == 0)
            {
              JOptionPane.showMessageDialog(this, response.toString());
            }
//                        db = new domainsDao();
//                        db.connect();
            Domain address = db.getDomain(domain.getDomainName());
//                        db.disconnect();
            domainPanel.setAddress(address);
          }
        }
        catch (EppSchemaException v)
        {
          v.printStackTrace();
        }
        catch (NullPointerException v)
        {
          v.printStackTrace();
        }
        catch (XmlException v)
        {
          v.printStackTrace();
        }
        catch (IOException v)
        {
          v.printStackTrace();
        }


        ListEntry entry = addressListPanel.getSelectedListEntry();
        entry.setDomainName(domain.getDomainName());
        addressListPanel.repaint();
        domainPanel.setEditable(false);
      }

      domain.setOldAdmin(domain.getAdmin());
      domain.setOldTech(domain.getTech());
      domain.setOldNameServer(domain.getNameServer());
      domain.setOldStatus(domain.getNewStatusV());
      domain.setOldAuthInfo(domain.getAuthInfo());
    }
  }

  public static byte[] parseHex(String hex) {
    if ((hex.length() & 1) != 0) {
      throw new IllegalArgumentException("Hex string must have even length");
    }

    int len = hex.length();
    byte[] out = new byte[len / 2];

    for (int i = 0; i < len; i += 2) {
      int hi = Character.digit(hex.charAt(i), 16);
      int lo = Character.digit(hex.charAt(i + 1), 16);

      if (hi == -1 || lo == -1) {
        throw new IllegalArgumentException("Invalid hex character");
      }

      out[i / 2] = (byte) ((hi << 4) + lo);
    }

    return out;
  }

  private void infoDomain()
  {
    String domainName = domainPanel.getDomainName();
    if (!domainName.equals(""))
    {

      try
      {
        DomainInfo domainInfo = new DomainInfo(domainName);
        logger.logmessage("CLIENT: " + domainInfo.toString());
        HttpBaseResponse response = EPPuplink.sendCommand(domainInfo);
        logger.logmessage("SERVER: " + response.toString() + "\n");

        if (response.isSuccessfully())
        {
          DomainRawInfo domainRawInfo = new DomainRawInfo(domainName, response.toString());
          domainRawInfo.setVisible(true);
        }
        else
        {
          if (JOptionPane.showConfirmDialog(this, "An error occurred while asking for Info Domain on Registry.\n\nDo you want to see the Registry XML response?", "Registry update failure", JOptionPane.YES_NO_OPTION, JOptionPane.WARNING_MESSAGE) == 0)
          {
            JOptionPane.showMessageDialog(this, response.toString());
          }
          parseDomainResult(response);
        }

/*                // send the logout command with verbose interaction
                Logout logout = new Logout();
                logger.logmessage("CLIENT: "+ logout.toString() + "\n");
                response = client.sendCommand(logout);
                logger.logmessage("SERVER: "+ response.toString());
 */
      }
      catch (NullPointerException v)
      {
      }
      catch (XmlException v)
      {
      }
      catch (IOException v)
      {
      }

    }
  }

  public void actionPerformed(ActionEvent e)
  {
    String actionCommand = e.getActionCommand();
    if (actionCommand.equalsIgnoreCase("CANCEL_ADDRESS"))
    {
      cancelAddress();
    }
    else if (actionCommand.equalsIgnoreCase("NEW_ADDRESS"))
    {
      newAddress();
    }
    else if (actionCommand.equalsIgnoreCase("TRANSFER_ADDRESS"))
    {
      transferAddress();
    }
    else if (actionCommand.equalsIgnoreCase("DELETE_ADDRESS"))
    {
      deleteDomain();
    }
    else if (actionCommand.equalsIgnoreCase("EDIT_ADDRESS"))
    {
      editAddress();
    }
    else if (actionCommand.equalsIgnoreCase("SAVE_ADDRESS"))
    {
      saveAddress();
    }
    else if (actionCommand.equalsIgnoreCase("CHECK_DOMAIN"))
    {
      checkDomain();
    }
    else if (actionCommand.equalsIgnoreCase("RESTORE_DOMAIN"))
    {
      restoreDomain();
    }
    else if (actionCommand.equalsIgnoreCase("SYNC_DOMAIN"))
    {
      syncDomainInfo();
    }
    else if (actionCommand.equalsIgnoreCase("INFO_DOMAIN"))
    {
      infoDomain();
    }
  }

  public void valueChanged(ListSelectionEvent e)
  {
    cancelAddress();
    if (e.getValueIsAdjusting())
    {
      return;
    }
    JList entryList = (JList) e.getSource();
    selectedEntry = entryList.getSelectedIndex();
    ListEntry entry = (ListEntry) entryList.getSelectedValue();
    if (entry != null)
    {
      String domainName = entry.getDomainName();
//            db = new domainsDao();
//            db.connect();
      Domain address = db.getDomain(domainName);
//            db.disconnect();
      domainPanel.setAddress(address);
    }
    else
    {
      domainPanel.clear();
    }
  }

  public void syncDomainInfo()
  {
    String domainName = (String) JOptionPane.showInputDialog(this, "Please digit the domain name you want to sync", "Domain Sync", JOptionPane.INFORMATION_MESSAGE, null, null, domainPanel.getDomainName());

    if (domainName != null)
    {
      ImportDomain syncDomain = new ImportDomain(mainFrame, true);
      if (syncDomain.execute(domainName))
      {
        addressListPanel.deleteAllEntries();
//                db = new domainsDao();
//                db.connect();
        List<ListEntry> entries = db.getListEntries();
//                db.disconnect();
        addressListPanel.addListEntries(entries);
      }
      else
      {
        switch (syncDomain.getResultCode())
        {
          case 2303:
            switch (syncDomain.getReasonCode())
            {
              case 9036:
                JOptionPane.showMessageDialog(this, "Il dominio " + domainName + " non esiste!", "Dominio inesistente", JOptionPane.WARNING_MESSAGE);
                break;
            }
            break;
          case 2202:
            switch (syncDomain.getReasonCode())
            {
              case 9001:
                JOptionPane.showMessageDialog(this, "Il dominio " + domainName + " appartiene ad un altro Registrar!", "Dominio di altro Registrar", JOptionPane.WARNING_MESSAGE);
                break;
            }
            break;
        }
      }

      syncDomain = null;
    }
  }


  private void checkDomain()
  {
    String domains = (String) JOptionPane.showInputDialog(this, "Please digit the domain(s) you want to Check for Availability", "Domain Availability Check", JOptionPane.INFORMATION_MESSAGE, null, null, "");
    try
    {
      DomainCheck domainCheck = new DomainCheck();
      for (String domainName : domains.split(";"))
      {
        domainCheck.addName(domainName);
      }

      HttpBaseResponse response = EPPuplink.sendCommand(domainCheck);
      logger.logmessage("SERVER: " + response.toString() + "\n");

      if (response.isSuccessfully())
      {
        String msgAvailabilityResult = "";
        DomainCheckResponseResData resData = (DomainCheckResponseResData) response.getResponseResData();
        for (int i = 0; i < resData.getChkSize(); i++)
        {
          msgAvailabilityResult += "" + resData.getChkName(i) + " : ";
          if (resData.getChkAvail(i))
          {
            msgAvailabilityResult += "Available";
          }
          else
          {
            msgAvailabilityResult += "NOT Available";
            if (resData.getChkReasonText(i) != null)
              msgAvailabilityResult += " (" + resData.getChkReasonText(i) + ")";
          }
          msgAvailabilityResult += "\n";
        }
        JOptionPane.showMessageDialog(this, msgAvailabilityResult, "Contact Check Result", JOptionPane.INFORMATION_MESSAGE);
      }
      else
      {
        if (JOptionPane.showConfirmDialog(this, "An error occurred while checking contact availability on the Registry.\n\nDo you want to see the Registry XML response?", "Registry contact check failure", JOptionPane.YES_NO_OPTION, JOptionPane.WARNING_MESSAGE) == 0)
        {
          JOptionPane.showMessageDialog(this, response.toString());
        }
      }


    }
    catch (NullPointerException v)
    {
    }
    catch (XmlException v)
    {
    }
    catch (IOException v)
    {
    }
  }


  public void restoreDomain()
  {
    String domainName = (String) JOptionPane.showInputDialog(this, "Please digit the domain name you want to restore", "Domain Restore from RGP", JOptionPane.INFORMATION_MESSAGE, null, null, domainPanel.getDomainName());

    if (domainName != null)
    {

      DomainUpdate domainUpdate = new DomainUpdate(domainName);
      domainUpdate.setRgpRestoreRequest();

      try
      {

        logger.logmessage("CLIENT: " + domainUpdate.toString() + "\n");
        HttpBaseResponse response = EPPuplink.sendCommand(domainUpdate);
        logger.logmessage("SERVER: " + response.toString() + "\n");
        if (response.isSuccessfully())
        {
          ImportDomain syncDomain = new ImportDomain(mainFrame, true);
          if (syncDomain.execute(domainName))
          {
            addressListPanel.deleteAllEntries();
//                        db = new domainsDao();
//                        db.connect();
            List<ListEntry> entries = db.getListEntries();
//                        db.disconnect();
            addressListPanel.addListEntries(entries);
            JOptionPane.showMessageDialog(this, "The domain name \"" + domainName + "\" has been successfully Restored.", "Domain Restore from RGP Result", JOptionPane.INFORMATION_MESSAGE);
          }

        }
        else
        {
          JOptionPane.showMessageDialog(this, "The domain name \"" + domainName + "\" has not been successfully Restored.\n\n" + response.getReasonMsgText(), "Domain Restore from RGP Result", JOptionPane.ERROR_MESSAGE);
        }

      }
      catch (NullPointerException v)
      {
      }
      catch (XmlException v)
      {
      }
      catch (IOException v)
      {
      }
    }
  }

  private void parseDomainResult(HttpBaseResponse response)
  {
    try
    {

      switch (response.getResultCode())
      {
        case 2303:
          if (response.getReasonCode() == 9036)
          {
            /*2012.06.15: Modifica libreria ITNIC*/
            //db.deleteRecord(response.getErrValue());
            db.deleteRecord(response.getErrValueTagValue(0));

            int selectedIndex = addressListPanel.deleteSelectedEntry();
            if (selectedIndex >= 0)
            {
              selectedIndex = addressListPanel.setSelectedIndex(selectedIndex);
              ListEntry entry = addressListPanel.getSelectedListEntry();
              if (entry != null)
              {
                Domain address = db.getDomain(entry.getDomainName());
                domainPanel.setAddress(address);
              }
              else
              {
                domainPanel.clear();
              }
            }
          }
          break;

        case 2202:
          if (response.getReasonCode() == 9085)
          {
            db.deleteRecord(response.getErrValueTagValue(0));

            int selectedIndex = addressListPanel.deleteSelectedEntry();
            if (selectedIndex >= 0)
            {
              selectedIndex = addressListPanel.setSelectedIndex(selectedIndex);
              ListEntry entry = addressListPanel.getSelectedListEntry();
              if (entry != null)
              {
                Domain address = db.getDomain(entry.getDomainName());
                domainPanel.setAddress(address);
              }
              else
              {
                domainPanel.clear();
              }
            }
          }
          break;
        default:
          break;
      }
    }
    catch (Exception e)
    {
      e.printStackTrace();
    }
  }

  public void setVisible(boolean b)
  {
    super.setVisible(b);
    if (b)
    {
      cancelAddress();
      refreshDomainList();
    }

  }

  private int selectedEntry = -1;
  private domainsDao db;
  private WindowAdapter windowAdapter;

  class WindowCloser extends WindowAdapter
  {
    @Override
    public void windowClosing(WindowEvent e)
    {
    }
  }


  // Variables declaration - do not modify//GEN-BEGIN:variables
  private DomainActionPanel addressActionPanel;
  private DomainPanel domainPanel;
  private DomainListPanel addressListPanel;
  // End of variables declaration//GEN-END:variables

  private logger logger;
  private EPPuplink EPPuplink;
}
